type OrchestratorArg = variant {
    UpgradeArg : UpgradeArg;
    InitArg : InitArg;
    AddErc20Arg : AddErc20Arg;
};

type InitArg = record {
    ledger_wasm: blob;
    index_wasm: blob;
    archive_wasm: blob;
};

type UpgradeArg = record {};

type AddErc20Arg = record {
   contract: Erc20Contract;
   ledger_init_arg: LedgerInitArg;
};

type Erc20Contract = record {
   chain_id: nat;
   address: text;
};

// ICRC1 ledger initialization argument that will be used when the orchestrator spawns a new ledger canister.
// The `archive_options` field will be set by the orchestrator.
type LedgerInitArg = record {
    minting_account : LedgerAccount;
    fee_collector_account : opt LedgerAccount;
    transfer_fee : nat;
    decimals : opt nat8;
    max_memo_length : opt nat16;
    token_symbol : text;
    token_name : text;
    token_logo : text;
    initial_balances : vec record { LedgerAccount; nat };
    feature_flags : opt LedgerFeatureFlags;
    maximum_number_of_accounts : opt nat64;
    accounts_overflow_trim_quantity : opt nat64;
};

type LedgerAccount = record {
    owner : principal;
    subaccount : opt LedgerSubaccount;
};

type LedgerSubaccount = blob;

type LedgerFeatureFlags = record {
    icrc2 : bool;
};

type ManagedCanisterIds = record {
   ledger: opt principal;
   index: opt principal;
   archives: vec principal;
};

service : (OrchestratorArg) -> {

   // Managed canister IDs for a given ERC20 contract
   canister_ids : (Erc20Contract) -> (opt ManagedCanisterIds) query;

}
