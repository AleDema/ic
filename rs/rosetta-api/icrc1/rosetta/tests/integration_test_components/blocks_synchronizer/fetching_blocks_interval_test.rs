use crate::common::local_replica;
use crate::common::local_replica::test_identity;

use ic_agent::Identity;
use ic_base_types::PrincipalId;
use ic_icrc1_ledger::InitArgs;
use ic_icrc_rosetta::common::storage::storage_client::StorageClient;
use ic_icrc_rosetta::common::utils::unit_test_utils::strategies::transfer_args_with_sender;
use ic_icrc_rosetta::common::utils::unit_test_utils::DEFAULT_TRANSFER_FEE;
use ic_icrc_rosetta::ledger_blocks_synchronization::blocks_synchronizer::{self, blocks_verifier};
use ic_ledger_canister_core::archive::ArchiveOptions;
use icrc_ledger_agent::Icrc1Agent;
use icrc_ledger_types::icrc1::account::Account;

use lazy_static::lazy_static;
use proptest::prelude::*;

use tokio::runtime::Runtime;

lazy_static! {
    pub static ref TEST_ACCOUNT: Account = test_identity().sender().unwrap().into();
    pub static ref MAX_NUM_GENERATED_BLOCKS: usize = 20;
    pub static ref NUM_TEST_CASES: u32 = 5;
}

proptest! {
    #![proptest_config(ProptestConfig::with_cases(*NUM_TEST_CASES))]
    #[test]
    fn test_simple_fetching_of_blocks_interval(transfer_args in transfer_args_with_sender(*MAX_NUM_GENERATED_BLOCKS, *TEST_ACCOUNT)) {
    // THe number of generated blocks will be the number of transfer arguments generated by proptest
    let num_of_generated_blocks = transfer_args.len();

    // Create a tokio environment to conduct async calls
    let rt = Runtime::new().unwrap();

    // Wrap async calls in a blocking Block
    rt.block_on(async {

    // Spin up a local replica
    let replica_context = local_replica::start_new_local_replica().await;

    // Deploy an icrc ledger canister
    let icrc_ledger_canister_id =
        local_replica::deploy_icrc_ledger_with_custom_args(&replica_context,
            InitArgs {
                minting_account: *TEST_ACCOUNT,
                fee_collector_account: None,
                initial_balances: vec![(*TEST_ACCOUNT,1_000_000_000_000)],
                transfer_fee: DEFAULT_TRANSFER_FEE.get_e8s(),
                token_name: "Test Token".to_owned(),
                token_symbol: "TT".to_owned(),
                metadata: vec![],
                archive_options: ArchiveOptions {
                    trigger_threshold: 10_000,
                    num_blocks_to_archive: 10_000,
                    node_max_memory_size_bytes: None,
                    max_message_size_bytes: None,
                    controller_id: PrincipalId::new_user_test_id(100),
                    cycles_for_archive_creation: None,
                    max_transactions_per_response: None,
                },
            }).await;

    // Create a testing agent
    let agent = Icrc1Agent {
        agent: local_replica::get_testing_agent(&replica_context).await,
        ledger_canister_id: icrc_ledger_canister_id.into(),
    };


    // Create some blocks in parallel to be fetched later
    for transfer_arg in transfer_args {
        agent.transfer(transfer_arg).await.unwrap().unwrap();
    }

    // Create the storage client where blocks will be stored
    let mut storage_client = StorageClient::new_in_memory().unwrap();

    // Start the synching process
    blocks_synchronizer::start_synching_blocks(&agent, &mut storage_client,2).await.unwrap();



    // Get the tip of the blockchain from the storage client
    let tip_block = storage_client
        .get_block_with_highest_block_idx()
        .unwrap();
    // Get the genesis block from the blockchain
    let genesis_block = storage_client
        .get_block_with_lowest_block_idx()
        .unwrap();

    // Get the the entire blockchain
    let blocks_stored = storage_client
    .get_blocks_by_index_range(0,num_of_generated_blocks as u64)
    .unwrap();


    // The index of the tip of the chain should be the number of generated blocks (Index starts at 0 and there exists a genesis block)
    assert_eq!(tip_block.unwrap().index as usize, num_of_generated_blocks.clone());

    // The index of the genesis block should be 0
    assert_eq!(genesis_block.unwrap().index as usize, 0);

    // The number of stored blocks should be the number of generated blocks plus the genesis block
    assert_eq!(blocks_stored.len(), num_of_generated_blocks+1);

    // Make sure the blocks that are stored are valid
    assert!(blocks_verifier::is_valid_blockchain(&blocks_stored,&blocks_stored.last().unwrap().block_hash));

        });

    }
}
