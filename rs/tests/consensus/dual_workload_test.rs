/* tag::catalog[]
Title:: Payload Builder Size Tests

Goal:: Test the consensus payload builder and the accompaning payload validator.

Runbook::
. Set up two subnets with one fast node each
. Install a universal canister in both, one is called target canister the other assist canister.
. The assist canister will be used to send the xnet data to the target canister.
. Send a bunch of large xnet and ingress messages to the same canister. Expect it to handle all of them eventually

Success:: The payload builder respects the boundaries set by the registry, while the payload validator
accepts all payloads generated by the payload builder.

Coverage::
. The system handles well under the load of large ingress messages and xnet messages at the same time.

end::catalog[] */

use futures::future::join_all;
use futures::FutureExt;
use ic_agent::{Agent, AgentError};
use ic_base_types::PrincipalId;
use ic_registry_subnet_type::SubnetType;
use ic_system_test_driver::driver::group::SystemTestGroup;
use ic_system_test_driver::driver::test_env_api::GetFirstHealthyNodeSnapshot;
use ic_system_test_driver::systest;
use ic_system_test_driver::{
    driver::{
        ic::{InternetComputer, Subnet},
        test_env::TestEnv,
        test_env_api::{HasPublicApiUrl, HasTopologySnapshot, IcNodeContainer},
    },
    util::UniversalCanister,
};
use ic_universal_canister::{call_args, wasm};

use anyhow::Result;
use slog::{info, Logger};
use std::sync::Arc;
use std::time::Duration;
use std::time::Instant;

const NUM_MSGS: usize = 32;
const MAX_SIZE: usize = 2 * 1024 * 1024;
const MSG_SIZE: usize = 1_900_000;

/// The configuration that is used for the dual workload test.
/// In this configuration, all sizes are set to 2MiB.
fn setup(env: TestEnv) {
    InternetComputer::new()
        .add_subnet(
            Subnet::new(SubnetType::System)
                .add_nodes(1)
                .with_initial_notary_delay(Duration::from_millis(300))
                .with_max_block_payload_size(MAX_SIZE as u64)
                .with_max_ingress_message_size(MAX_SIZE as u64),
        )
        .add_subnet(Subnet::new(SubnetType::Application).add_nodes(1))
        .setup_and_start(&env)
        .expect("failed to setup IC under test");

    info!(
        env.logger(),
        "Checking readiness of all nodes after the IC setup..."
    );
    for subnet in env.topology_snapshot().subnets() {
        for node in subnet.nodes() {
            node.await_status_is_healthy().unwrap();
        }
    }
    info!(env.logger(), "All nodes are ready, IC setup succeeded.");
}

/// Tests, that the internet computer behaves well, when there is a high load of
/// ingress messages and xnet messages on the same subnet.
fn test(env: TestEnv) {
    let log = env.logger();

    let target_node_nns = env.get_first_healthy_system_node_snapshot();
    let assist_node_app = env.get_first_healthy_application_node_snapshot();

    let rt = tokio::runtime::Runtime::new().expect("Could not create tokio runtime.");
    rt.block_on(async move {
        let assist_agent = assist_node_app.build_default_agent_async().await;
        let target_agent = target_node_nns.build_default_agent_async().await;

        let assist_unican =
            setup_unican(&log, &assist_agent, assist_node_app.effective_canister_id()).await;
        let target_unican =
            setup_unican(&log, &target_agent, target_node_nns.effective_canister_id()).await;

        let futures = (0..NUM_MSGS).flat_map(|index| {
            vec![
                make_xnet_call(
                    target_unican.clone(),
                    assist_unican.clone(),
                    index,
                    MSG_SIZE,
                    log.clone(),
                )
                .boxed(),
                make_ingress_call(target_unican.clone(), index, MSG_SIZE, log.clone()).boxed(),
            ]
        });

        join_all(futures).await;
    });
}

async fn setup_unican<'a>(
    logger: &Logger,
    agent: &'a Agent,
    effective_canister_id: PrincipalId,
) -> Arc<UniversalCanister<'a>> {
    // Install a `UniversalCanister`
    let unican = UniversalCanister::new_with_retries(agent, effective_canister_id, logger).await;

    // NOTE: Since we will be making calls to these canisters in parallel, we have
    // to make it `Send`.
    let unican = Arc::new(unican);

    // Grow the stable memory so it can actually store the amount of data
    stable_grow(&unican, 100).await;

    unican
}

/// Grow the canisters stable memory by the given number of pages
async fn stable_grow(unican: &UniversalCanister<'_>, num_pages: u32) {
    unican
        .update(wasm().stable_grow(num_pages).reply())
        .await
        .unwrap();
}

/// Makes an ingress call to the specified canister with a message of the
/// specified size.
async fn make_ingress_call(
    dst: Arc<UniversalCanister<'_>>,
    index: usize,
    size: usize,
    logger: Logger,
) -> Result<Vec<u8>, AgentError> {
    let start = Instant::now();
    // NOTE: We use reply here before stable write, since we don't actually
    // care about the write, we just want to send a large message.
    let res = dst
        .update(wasm().reply().stable_write(0, &vec![0; size]))
        .await;
    info!(
        logger,
        "Ingress call {} finished after {}s",
        index,
        start.elapsed().as_secs()
    );

    res
}

/// Makes a XNet call from the `src` canister to the `dst` canister with a
/// message of the specified size
async fn make_xnet_call(
    dst: Arc<UniversalCanister<'_>>,
    src: Arc<UniversalCanister<'_>>,
    index: usize,
    size: usize,
    logger: Logger,
) -> Result<Vec<u8>, AgentError> {
    let start = Instant::now();
    let res = src
        .update(
            wasm().inter_update(
                dst.canister_id(),
                call_args()
                    // NOTE: We use reply here before stable write, since we don't actually
                    // care about the write, we just want to send a large message.
                    .other_side(wasm().reply().stable_write(0, &vec![0; size]))
                    .on_reply(wasm().reply()),
            ),
        )
        .await;
    info!(
        logger,
        "XNet call {} finished after {}s",
        index,
        start.elapsed().as_secs()
    );

    res
}

fn main() -> Result<()> {
    SystemTestGroup::new()
        .with_setup(setup)
        .add_test(systest!(test))
        .execute_from_args()?;
    Ok(())
}
